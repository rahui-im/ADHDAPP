import { TimerState, TimerSettings, Session } from '../types'

export interface CycleData {
  currentCycle: number
  totalCycles: number
  cyclesUntilLongBreak: number
  isLongBreakTime: boolean
  nextMode: 'focus' | 'short-break' | 'long-break'
  completedSessions: Session[]
}

export class CycleManagerService {
  private static instance: CycleManagerService

  private constructor() {}

  static getInstance(): CycleManagerService {
    if (!CycleManagerService.instance) {
      CycleManagerService.instance = new CycleManagerService()
    }
    return CycleManagerService.instance
  }

  /**
   * ë‹¤ìŒ ëª¨ë“œ ê²°ì • (í¬ëª¨ë„ë¡œ ì™„ë£Œ í›„)
   */
  determineNextMode(
    currentMode: TimerState['mode'],
    totalCycles: number,
    settings: TimerSettings
  ): {
    nextMode: TimerState['mode']
    isLongBreakTime: boolean
    cyclesUntilLongBreak: number
  } {
    if (currentMode === 'focus') {
      // ì§‘ì¤‘ ì‹œê°„ ì™„ë£Œ í›„
      const completedCycles = totalCycles + 1
      const isLongBreakTime = completedCycles % settings.cyclesBeforeLongBreak === 0
      
      return {
        nextMode: isLongBreakTime ? 'long-break' : 'short-break',
        isLongBreakTime,
        cyclesUntilLongBreak: isLongBreakTime 
          ? settings.cyclesBeforeLongBreak 
          : settings.cyclesBeforeLongBreak - (completedCycles % settings.cyclesBeforeLongBreak)
      }
    } else {
      // íœ´ì‹ ì‹œê°„ ì™„ë£Œ í›„ -> í•­ìƒ ì§‘ì¤‘ ì‹œê°„
      return {
        nextMode: 'focus',
        isLongBreakTime: false,
        cyclesUntilLongBreak: settings.cyclesBeforeLongBreak - (totalCycles % settings.cyclesBeforeLongBreak)
      }
    }
  }

  /**
   * ì‚¬ì´í´ ë°ì´í„° ê³„ì‚°
   */
  calculateCycleData(
    currentCycle: number,
    totalCycles: number,
    settings: TimerSettings,
    completedSessions: Session[] = []
  ): CycleData {
    const cyclesUntilLongBreak = settings.cyclesBeforeLongBreak - (totalCycles % settings.cyclesBeforeLongBreak)
    const isLongBreakTime = cyclesUntilLongBreak === 0

    return {
      currentCycle,
      totalCycles,
      cyclesUntilLongBreak: isLongBreakTime ? settings.cyclesBeforeLongBreak : cyclesUntilLongBreak,
      isLongBreakTime,
      nextMode: isLongBreakTime ? 'long-break' : 'short-break',
      completedSessions
    }
  }

  /**
   * ê¸´ íœ´ì‹ ì œì•ˆ ë©”ì‹œì§€ ìƒì„±
   */
  generateLongBreakSuggestion(totalCycles: number, settings: TimerSettings): {
    title: string
    message: string
    suggestions: string[]
  } {
    const completedSets = Math.floor(totalCycles / settings.cyclesBeforeLongBreak)
    
    return {
      title: `ğŸ‰ ${settings.cyclesBeforeLongBreak}íšŒ í¬ëª¨ë„ë¡œ ì™„ë£Œ!`,
      message: `ì •ë§ í›Œë¥­í•´ìš”! ${completedSets}ì„¸íŠ¸ë¥¼ ì™„ë£Œí–ˆìŠµë‹ˆë‹¤. ì´ì œ ê¸´ íœ´ì‹ì„ ì·¨í•  ì‹œê°„ì´ì—ìš”.`,
      suggestions: [
        'ì‚°ì±…í•˜ê¸° ë˜ëŠ” ê°€ë²¼ìš´ ìš´ë™',
        'ì¢‹ì•„í•˜ëŠ” ìŒì•… ë“£ê¸°',
        'ê°„ë‹¨í•œ ìŠ¤íŠ¸ë ˆì¹­',
        'ëª…ìƒì´ë‚˜ ê¹Šì€ í˜¸í¡',
        'ê±´ê°•í•œ ê°„ì‹ ë¨¹ê¸°',
        'ì°½ë°– í’ê²½ ë³´ê¸°',
      ]
    }
  }

  /**
   * ì‚¬ì´í´ ì§„í–‰ë¥  ê³„ì‚° (0-100%)
   */
  calculateCycleProgress(totalCycles: number, settings: TimerSettings): number {
    const currentSetProgress = (totalCycles % settings.cyclesBeforeLongBreak) / settings.cyclesBeforeLongBreak
    return Math.round(currentSetProgress * 100)
  }

  /**
   * ì˜¤ëŠ˜ì˜ í¬ëª¨ë„ë¡œ í†µê³„ ê³„ì‚°
   */
  calculateDailyStats(sessions: Session[]): {
    totalFocusTime: number // minutes
    totalBreakTime: number // minutes
    completedPomodoros: number
    averageSessionLength: number // minutes
    interruptionRate: number // percentage
  } {
    const today = new Date().toDateString()
    const todaySessions = sessions.filter(session => 
      session.startedAt.toDateString() === today
    )

    const focusSessions = todaySessions.filter(s => s.type === 'focus')
    const breakSessions = todaySessions.filter(s => s.type === 'break')

    const totalFocusTime = focusSessions.reduce((sum, s) => sum + s.actualDuration, 0)
    const totalBreakTime = breakSessions.reduce((sum, s) => sum + s.actualDuration, 0)
    const completedPomodoros = focusSessions.filter(s => s.completedAt).length
    const interruptedSessions = todaySessions.filter(s => s.wasInterrupted).length
    
    return {
      totalFocusTime,
      totalBreakTime,
      completedPomodoros,
      averageSessionLength: todaySessions.length > 0 
        ? Math.round((totalFocusTime + totalBreakTime) / todaySessions.length)
        : 0,
      interruptionRate: todaySessions.length > 0 
        ? Math.round((interruptedSessions / todaySessions.length) * 100)
        : 0
    }
  }

  /**
   * ì£¼ê°„ ì‚¬ì´í´ íŒ¨í„´ ë¶„ì„
   */
  analyzeWeeklyPattern(sessions: Session[]): {
    bestDayOfWeek: string
    bestTimeOfDay: number // hour (0-23)
    averageSessionsPerDay: number
    consistencyScore: number // 0-100
  } {
    const oneWeekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
    const recentSessions = sessions.filter(session => 
      session.startedAt >= oneWeekAgo
    )

    if (recentSessions.length === 0) {
      return {
        bestDayOfWeek: 'ë°ì´í„° ì—†ìŒ',
        bestTimeOfDay: 9,
        averageSessionsPerDay: 0,
        consistencyScore: 0
      }
    }

    // ìš”ì¼ë³„ ì„¸ì…˜ ìˆ˜ ê³„ì‚°
    const dayCount: { [key: string]: number } = {}
    const hourCount: { [key: number]: number } = {}
    const dailyCount: { [key: string]: number } = {}

    recentSessions.forEach(session => {
      const dayOfWeek = session.startedAt.toLocaleDateString('ko-KR', { weekday: 'long' })
      const hour = session.startedAt.getHours()
      const dateKey = session.startedAt.toDateString()

      dayCount[dayOfWeek] = (dayCount[dayOfWeek] || 0) + 1
      hourCount[hour] = (hourCount[hour] || 0) + 1
      dailyCount[dateKey] = (dailyCount[dateKey] || 0) + 1
    })

    // ê°€ì¥ í™œë°œí•œ ìš”ì¼
    const bestDayOfWeek = Object.entries(dayCount)
      .sort(([,a], [,b]) => b - a)[0]?.[0] || 'ë°ì´í„° ì—†ìŒ'

    // ê°€ì¥ í™œë°œí•œ ì‹œê°„ëŒ€
    const bestTimeOfDay = Object.entries(hourCount)
      .sort(([,a], [,b]) => b - a)[0]?.[0] || '9'

    // ì¼í‰ê·  ì„¸ì…˜ ìˆ˜
    const averageSessionsPerDay = recentSessions.length / 7

    // ì¼ê´€ì„± ì ìˆ˜ (ë§¤ì¼ ì„¸ì…˜ì´ ìˆìœ¼ë©´ 100ì )
    const daysWithSessions = Object.keys(dailyCount).length
    const consistencyScore = Math.round((daysWithSessions / 7) * 100)

    return {
      bestDayOfWeek,
      bestTimeOfDay: parseInt(bestTimeOfDay),
      averageSessionsPerDay: Math.round(averageSessionsPerDay * 10) / 10,
      consistencyScore
    }
  }

  /**
   * ê°œì¸í™”ëœ ì‚¬ì´í´ ì¶”ì²œ
   */
  getPersonalizedRecommendations(
    sessions: Session[],
    settings: TimerSettings
  ): {
    recommendedCycleLength: number
    recommendedLongBreakDuration: number
    suggestions: string[]
  } {
    const recentSessions = sessions.slice(-20) // ìµœê·¼ 20ê°œ ì„¸ì…˜
    const focusSessions = recentSessions.filter(s => s.type === 'focus')
    
    if (focusSessions.length === 0) {
      return {
        recommendedCycleLength: settings.cyclesBeforeLongBreak,
        recommendedLongBreakDuration: settings.longBreakDuration,
        suggestions: ['ë” ë§ì€ ë°ì´í„°ê°€ í•„ìš”í•©ë‹ˆë‹¤']
      }
    }

    const averageCompletionRate = focusSessions.filter(s => !s.wasInterrupted).length / focusSessions.length
    const averageEnergyAfter = focusSessions.reduce((sum, s) => sum + s.energyAfter, 0) / focusSessions.length

    const suggestions: string[] = []
    let recommendedCycleLength = settings.cyclesBeforeLongBreak
    let recommendedLongBreakDuration = settings.longBreakDuration

    if (averageCompletionRate < 0.7) {
      recommendedCycleLength = Math.max(2, settings.cyclesBeforeLongBreak - 1) as 3
      suggestions.push('ë” ìì£¼ ê¸´ íœ´ì‹ì„ ì·¨í•´ë³´ì„¸ìš”')
    }

    if (averageEnergyAfter < 3) {
      recommendedLongBreakDuration = Math.min(45, settings.longBreakDuration + 5) as 25
      suggestions.push('ê¸´ íœ´ì‹ ì‹œê°„ì„ ëŠ˜ë ¤ë³´ì„¸ìš”')
    }

    if (averageCompletionRate > 0.9 && averageEnergyAfter > 3.5) {
      recommendedCycleLength = Math.min(6, settings.cyclesBeforeLongBreak + 1) as 3
      suggestions.push('ë” ê¸´ ì‚¬ì´í´ì— ë„ì „í•´ë³´ì„¸ìš”')
    }

    return {
      recommendedCycleLength,
      recommendedLongBreakDuration,
      suggestions: suggestions.length > 0 ? suggestions : ['í˜„ì¬ ì„¤ì •ì´ ì˜ ë§ëŠ” ê²ƒ ê°™ì•„ìš”!']
    }
  }
}

export const cycleManagerService = CycleManagerService.getInstance()